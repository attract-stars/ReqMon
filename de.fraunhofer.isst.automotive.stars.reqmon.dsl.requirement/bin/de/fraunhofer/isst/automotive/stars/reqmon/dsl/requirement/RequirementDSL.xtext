grammar de.fraunhofer.isst.stars.RequirementDSL with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate requirementDSL "http://www.fraunhofer.de/isst/stars/RequirementDSL"

/* =========== Model =========== */

Model:
	requirements+=Requirement*
;

//Requirement:
//	(condClauses+=Subclause)* (mainclauses+=Clauses) (condClauses+=Subclause)*
//	;

Requirement:
	//PROBLEM condClauses before and after mainClause lead to ambiguity
	'Req'? reqID=ReqID? (':'|'.') text=RequirementText ('.'|';')?
;

RequirementText:
    (condClauses+=ConditionalClause)?  (mainclauses=MainClause) (condClauses+=ConditionalClause)?
;

/* =========== Clauses =========== */

ConditionalClause:
	ordinator=ClauseOrdinator clauses=Clauses
;

MainClause:
	(modifier=Modifier)? clauses+=Clause //(conjunction+=Conjunction clauses+=MainClause)*
;


Clauses:
	clauses+= Clause (conjunction+=Conjunction clauses+=Clause)*
;

Clause:
//Evtl. kann man Verb und Activity zu Predicate vereinen als String
// subject=Subjects (modelity=Modality negation?=Negation? auxverb=AuxiliarVerb? | auxverb=AuxiliarVerb negation?=Negation?)? predicate=Predicate constraints+=Constraints*
 subject=Subjects modelity=Modality? (negation?=Negation? & auxverb=AuxiliarVerb?) predicate=Predicate constraints+=Constraints*
 //PROBLEM dass hier 'is' als AuxiliarVerb das is als Verb im Predicate überdeckt! -> Lösung? Auxiliary Verbs als Predicates skippen!?
;

Subjects:
	(subject+=Object) (conjunction+=Conjunction subject+=Object)*
;

Object:
	// object=ID id=ID? | object=STRING;
    determiner=Determiner? (object=ID | object=STRING)
;


/* =========== VERB FORMS =========== */



Predicate:
	//verb=Verb | activity=Activity
	ID | STRING
;

/* =========== VALUES =========== */


ValueSet:
	 '{' (elements+=Value) (';'elements+=Value)*'}'
;

ObjectSet:
	  '{' (elements+=Object) (';'elements+=Object)*'}'
;

Value:
	IntValue| FloatValue
;

IntValue:
	value=INT unit=Unit?
;

FloatValue:
	value=FLOAT  unit=Unit?
;



/* =========== CONSTRAINTS =========== */

Constraints:
	timeConstraint= TimeConstraint | constraint=Constraint
;

Constraint:
	constraintOrdinators=ConstraintOrdinators (constraint=ObjectConstraint | constraint=UnitConstraints | constraint= SetConstraint)
;	

ConstraintOrdinators:
	stuffing=StuffWord? adverbial=Adverbial comperator=Comperators?
;


	
SetConstraint:
	//Difference between ObjectSet and Value set in order to exclude a mixture of both in a single set
	set=ObjectSet  | set=ValueSet
;

TimeConstraint:
	ordinator=ConstraintOrdinators time=INT unit=TimeUnits
;

ObjectConstraint:
	  object=Object
;


UnitConstraints:
	 SingleValueConstraints | IntervallConstraints
;


IntervallConstraints:
	'[' lower=Value','higher=Value ']'
;

SingleValueConstraints:
	 value=Value
;

/* =========== COMPARISON =========== */



/* =========== XXX =========== */

ReqID returns  ecore::EString: 
	ID ('.'|INT)* 
;


/* =========== BASIC SYNTAX =========== */

Conjunction:
	'and'| 'or';


AuxiliarVerb:
	'does' | 'do' | 'is' | 'are' | 'be' | 'been'
;

Comperators:
	'than'|'as'|'to'
;
		 
Adverbial:
	'higher' | 'between'| 'next' | 'less'| 'more' | 'larger' | 'smaller' | 'equal' | 'on' | 'above' | 'below' | 'in' | 'within' | 'for' | 'as_long_as' | 'to' | 'by'  |'faster' | 'slower' | 'better' | 'in_front_of' | 'behind'
;

Determiner:
	'all' | 'every' | 'each' | 'whole' | 'any' | 'several' | 'either'
;

Negation:
	'not' | 'donot' | 'doesnot' | 'doesn\'t' | 'don\'t'
;

enum Modality:
	  SHALL = 'shall' | SHOULD = 'should' | WILL = 'will' | WOULD='would' | CAN='can' | COULD='could' | MUST='must'
;

enum Modifier:
	GLOBALLY='Globally' | GLOBALLY='globally' | ALWAYS='Always' | ALWAYS='always' | SOMETIMES='Sometimes' | SOMETIMES='sometimes' | EVENTUALLY='Eventually' | EVENTUALLY='eventually'
;

enum ClauseOrdinator:
	IF='if' | AFTER='after' | ONCE='once' | WHEN='when' | WHENEVER='whenever' | WHILE='while' | BEFORE='before' | UNTIL='until'
;

StuffWord:
	'with'
;	

/* =========== BASIC UNITS =========== */

terminal FLOAT returns ecore::EFloat:
	INT'.'INT
;

Unit:
	 LengthUnits | PresureUnits | HeatUnits | MassUnits | VelcoityUnits | Cuvature
;


Cuvature:
	'rad/m' | '°' | 'rad' | '°/m'	
;

VelcoityUnits:
	'm/s' | 'knots'  |'km/h' | 'm/min'
	;

MassUnits:
	'kg'| 'g' | 'mg' | 't'
;

HeatUnits:
	'C' | 'F'
;

PresureUnits:
	'bar' | 'Pa' | 'hPa'
;


LengthUnits:
	'm' | 'f' | 'km' | 'cm' | 'mm' |'nm'
;

TimeUnits:
	 'ns'|'ms'|'s' | 'sec' | 'second' | 'seconds'| 'minute' | 'minutes' | 'min' | 'hour' | 'hours' | 'h' | 'day' | 'days' | 'd' | 'month'| 'months' | 'mon' |'year'| 'years'| 'y' 
;
