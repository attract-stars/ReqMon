/*
 * generated by Xtext 2.17.1
 */
package de.fraunhofer.isst.stars.serializer;

import com.google.inject.Inject;
import de.fraunhofer.isst.stars.requirementDSL.Actor;
import de.fraunhofer.isst.stars.requirementDSL.Actors;
import de.fraunhofer.isst.stars.requirementDSL.AuxNeg;
import de.fraunhofer.isst.stars.requirementDSL.Clauses;
import de.fraunhofer.isst.stars.requirementDSL.ConditionalClause;
import de.fraunhofer.isst.stars.requirementDSL.Constraint;
import de.fraunhofer.isst.stars.requirementDSL.ConstraintOrdinators;
import de.fraunhofer.isst.stars.requirementDSL.Constraints;
import de.fraunhofer.isst.stars.requirementDSL.ExistencePreface;
import de.fraunhofer.isst.stars.requirementDSL.FloatValue;
import de.fraunhofer.isst.stars.requirementDSL.IntValue;
import de.fraunhofer.isst.stars.requirementDSL.IntervallConstraints;
import de.fraunhofer.isst.stars.requirementDSL.MainClause;
import de.fraunhofer.isst.stars.requirementDSL.ModalitySentence;
import de.fraunhofer.isst.stars.requirementDSL.Model;
import de.fraunhofer.isst.stars.requirementDSL.ObjectConstraint;
import de.fraunhofer.isst.stars.requirementDSL.ObjectSet;
import de.fraunhofer.isst.stars.requirementDSL.PreNominative;
import de.fraunhofer.isst.stars.requirementDSL.PredOrObject;
import de.fraunhofer.isst.stars.requirementDSL.Predicate;
import de.fraunhofer.isst.stars.requirementDSL.PredicateObject;
import de.fraunhofer.isst.stars.requirementDSL.PredicateSentence;
import de.fraunhofer.isst.stars.requirementDSL.Preds;
import de.fraunhofer.isst.stars.requirementDSL.Property;
import de.fraunhofer.isst.stars.requirementDSL.PropertySentence;
import de.fraunhofer.isst.stars.requirementDSL.RelObjects;
import de.fraunhofer.isst.stars.requirementDSL.Relation;
import de.fraunhofer.isst.stars.requirementDSL.Requirement;
import de.fraunhofer.isst.stars.requirementDSL.RequirementDSLPackage;
import de.fraunhofer.isst.stars.requirementDSL.RequirementText;
import de.fraunhofer.isst.stars.requirementDSL.SentenceBegin;
import de.fraunhofer.isst.stars.requirementDSL.SentenceEnding;
import de.fraunhofer.isst.stars.requirementDSL.SetConstraint;
import de.fraunhofer.isst.stars.requirementDSL.SingleValueConstraints;
import de.fraunhofer.isst.stars.requirementDSL.TimeConstraint;
import de.fraunhofer.isst.stars.requirementDSL.ValueSet;
import de.fraunhofer.isst.stars.requirementDSL.relativeClause;
import de.fraunhofer.isst.stars.requirementDSL.relativeSentence;
import de.fraunhofer.isst.stars.services.RequirementDSLGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class RequirementDSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RequirementDSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RequirementDSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RequirementDSLPackage.ACTOR:
				sequence_Actor(context, (Actor) semanticObject); 
				return; 
			case RequirementDSLPackage.ACTORS:
				sequence_Actors(context, (Actors) semanticObject); 
				return; 
			case RequirementDSLPackage.AUX_NEG:
				sequence_AuxNeg(context, (AuxNeg) semanticObject); 
				return; 
			case RequirementDSLPackage.CLAUSES:
				sequence_Clauses(context, (Clauses) semanticObject); 
				return; 
			case RequirementDSLPackage.CONDITIONAL_CLAUSE:
				sequence_ConditionalClause(context, (ConditionalClause) semanticObject); 
				return; 
			case RequirementDSLPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case RequirementDSLPackage.CONSTRAINT_ORDINATORS:
				sequence_ConstraintOrdinators(context, (ConstraintOrdinators) semanticObject); 
				return; 
			case RequirementDSLPackage.CONSTRAINTS:
				sequence_Constraints(context, (Constraints) semanticObject); 
				return; 
			case RequirementDSLPackage.EXISTENCE_PREFACE:
				if (rule == grammarAccess.getExistencePrefaceRule()) {
					sequence_ExistencePreface(context, (ExistencePreface) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getClauseRule()
						|| rule == grammarAccess.getExistenceSentenceRule()) {
					sequence_ExistencePreface_ExistenceSentence(context, (ExistencePreface) semanticObject); 
					return; 
				}
				else break;
			case RequirementDSLPackage.FLOAT_VALUE:
				sequence_FloatValue(context, (FloatValue) semanticObject); 
				return; 
			case RequirementDSLPackage.INT_VALUE:
				sequence_IntValue(context, (IntValue) semanticObject); 
				return; 
			case RequirementDSLPackage.INTERVALL_CONSTRAINTS:
				sequence_IntervallConstraints(context, (IntervallConstraints) semanticObject); 
				return; 
			case RequirementDSLPackage.MAIN_CLAUSE:
				sequence_MainClause(context, (MainClause) semanticObject); 
				return; 
			case RequirementDSLPackage.MODALITY_SENTENCE:
				sequence_ModalitySentence(context, (ModalitySentence) semanticObject); 
				return; 
			case RequirementDSLPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case RequirementDSLPackage.OBJECT:
				sequence_Object(context, (de.fraunhofer.isst.stars.requirementDSL.Object) semanticObject); 
				return; 
			case RequirementDSLPackage.OBJECT_CONSTRAINT:
				sequence_ObjectConstraint(context, (ObjectConstraint) semanticObject); 
				return; 
			case RequirementDSLPackage.OBJECT_SET:
				sequence_ObjectSet(context, (ObjectSet) semanticObject); 
				return; 
			case RequirementDSLPackage.PRE_NOMINATIVE:
				if (rule == grammarAccess.getActorRule()) {
					sequence_Actor_PreNominative(context, (PreNominative) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPreNominativeRule()) {
					sequence_PreNominative(context, (PreNominative) semanticObject); 
					return; 
				}
				else break;
			case RequirementDSLPackage.PRED_OR_OBJECT:
				sequence_PredOrObject(context, (PredOrObject) semanticObject); 
				return; 
			case RequirementDSLPackage.PREDICATE:
				sequence_Predicate(context, (Predicate) semanticObject); 
				return; 
			case RequirementDSLPackage.PREDICATE_OBJECT:
				sequence_PredicateObject(context, (PredicateObject) semanticObject); 
				return; 
			case RequirementDSLPackage.PREDICATE_SENTENCE:
				sequence_PredicateSentence(context, (PredicateSentence) semanticObject); 
				return; 
			case RequirementDSLPackage.PREDS:
				sequence_Preds(context, (Preds) semanticObject); 
				return; 
			case RequirementDSLPackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case RequirementDSLPackage.PROPERTY_SENTENCE:
				sequence_PropertySentence(context, (PropertySentence) semanticObject); 
				return; 
			case RequirementDSLPackage.REL_OBJECTS:
				sequence_RelObjects(context, (RelObjects) semanticObject); 
				return; 
			case RequirementDSLPackage.RELATION:
				sequence_Relation(context, (Relation) semanticObject); 
				return; 
			case RequirementDSLPackage.REQUIREMENT:
				sequence_Requirement(context, (Requirement) semanticObject); 
				return; 
			case RequirementDSLPackage.REQUIREMENT_TEXT:
				sequence_RequirementText(context, (RequirementText) semanticObject); 
				return; 
			case RequirementDSLPackage.SENTENCE_BEGIN:
				sequence_SentenceBegin(context, (SentenceBegin) semanticObject); 
				return; 
			case RequirementDSLPackage.SENTENCE_ENDING:
				sequence_SentenceEnding(context, (SentenceEnding) semanticObject); 
				return; 
			case RequirementDSLPackage.SET_CONSTRAINT:
				sequence_SetConstraint(context, (SetConstraint) semanticObject); 
				return; 
			case RequirementDSLPackage.SINGLE_VALUE_CONSTRAINTS:
				sequence_SingleValueConstraints(context, (SingleValueConstraints) semanticObject); 
				return; 
			case RequirementDSLPackage.TIME_CONSTRAINT:
				sequence_TimeConstraint(context, (TimeConstraint) semanticObject); 
				return; 
			case RequirementDSLPackage.VALUE_SET:
				sequence_ValueSet(context, (ValueSet) semanticObject); 
				return; 
			case RequirementDSLPackage.RELATIVE_CLAUSE:
				sequence_relativeClause(context, (relativeClause) semanticObject); 
				return; 
			case RequirementDSLPackage.RELATIVE_SENTENCE:
				sequence_relativeSentence(context, (relativeSentence) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Actor returns Actor
	 *
	 * Constraint:
	 *     (actor=WORD | actor=STRING)
	 */
	protected void sequence_Actor(ISerializationContext context, Actor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Actor returns PreNominative
	 *
	 * Constraint:
	 *     ((determiner=Quantification | article=Articles | article=RefArticles) (actor=WORD | actor=STRING))
	 */
	protected void sequence_Actor_PreNominative(ISerializationContext context, PreNominative semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Actors returns Actors
	 *
	 * Constraint:
	 *     (actors+=Actor (conjunction+=Conjunction actors+=Actor)*)
	 */
	protected void sequence_Actors(ISerializationContext context, Actors semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AuxNeg returns AuxNeg
	 *
	 * Constraint:
	 *     ((auxiliarVerb=AuxiliaryVerb negation=Negation?) | auxiliarVerbNeg=AuxiliaryVerbNegation)
	 */
	protected void sequence_AuxNeg(ISerializationContext context, AuxNeg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clauses returns Clauses
	 *
	 * Constraint:
	 *     (clauses+=Clause (conjunction+=Conjunction clauses+=Clause)*)
	 */
	protected void sequence_Clauses(ISerializationContext context, Clauses semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionalClause returns ConditionalClause
	 *
	 * Constraint:
	 *     (ordinator=ClauseOrdinator clauses=Clauses)
	 */
	protected void sequence_ConditionalClause(ISerializationContext context, ConditionalClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RequirementDSLPackage.Literals.CONDITIONAL_CLAUSE__ORDINATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RequirementDSLPackage.Literals.CONDITIONAL_CLAUSE__ORDINATOR));
			if (transientValues.isValueTransient(semanticObject, RequirementDSLPackage.Literals.CONDITIONAL_CLAUSE__CLAUSES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RequirementDSLPackage.Literals.CONDITIONAL_CLAUSE__CLAUSES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalClauseAccess().getOrdinatorClauseOrdinatorEnumRuleCall_0_0(), semanticObject.getOrdinator());
		feeder.accept(grammarAccess.getConditionalClauseAccess().getClausesClausesParserRuleCall_1_0(), semanticObject.getClauses());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConstraintOrdinators returns ConstraintOrdinators
	 *
	 * Constraint:
	 *     (stuffing=StuffWord? adverbial=Adverbial comperator=Comperators?)
	 */
	protected void sequence_ConstraintOrdinators(ISerializationContext context, ConstraintOrdinators semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Constraint
	 *
	 * Constraint:
	 *     (ordinator=ConstraintOrdinators (constraint=ObjectConstraint | constraint=UnitConstraints | constraint=SetConstraint))
	 */
	protected void sequence_Constraint(ISerializationContext context, Constraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraints returns Constraints
	 *
	 * Constraint:
	 *     (timeConstraint=TimeConstraint | constraint=Constraint)
	 */
	protected void sequence_Constraints(ISerializationContext context, Constraints semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExistencePreface returns ExistencePreface
	 *
	 * Constraint:
	 *     modifier=Modifier?
	 */
	protected void sequence_ExistencePreface(ISerializationContext context, ExistencePreface semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns ExistencePreface
	 *     ExistenceSentence returns ExistencePreface
	 *
	 * Constraint:
	 *     (modifier=Modifier? actors=Actors relativeClause=relativeClause)
	 */
	protected void sequence_ExistencePreface_ExistenceSentence(ISerializationContext context, ExistencePreface semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Value returns FloatValue
	 *     FloatValue returns FloatValue
	 *
	 * Constraint:
	 *     (value=FLOAT unit=Unit? object+=WORD*)
	 */
	protected void sequence_FloatValue(ISerializationContext context, FloatValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Value returns IntValue
	 *     IntValue returns IntValue
	 *
	 * Constraint:
	 *     (value=INT unit=Unit? object+=WORD*)
	 */
	protected void sequence_IntValue(ISerializationContext context, IntValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitConstraints returns IntervallConstraints
	 *     IntervallConstraints returns IntervallConstraints
	 *
	 * Constraint:
	 *     (lower=Value higher=Value)
	 */
	protected void sequence_IntervallConstraints(ISerializationContext context, IntervallConstraints semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RequirementDSLPackage.Literals.INTERVALL_CONSTRAINTS__LOWER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RequirementDSLPackage.Literals.INTERVALL_CONSTRAINTS__LOWER));
			if (transientValues.isValueTransient(semanticObject, RequirementDSLPackage.Literals.INTERVALL_CONSTRAINTS__HIGHER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RequirementDSLPackage.Literals.INTERVALL_CONSTRAINTS__HIGHER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntervallConstraintsAccess().getLowerValueParserRuleCall_1_0(), semanticObject.getLower());
		feeder.accept(grammarAccess.getIntervallConstraintsAccess().getHigherValueParserRuleCall_3_0(), semanticObject.getHigher());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MainClause returns MainClause
	 *
	 * Constraint:
	 *     (modifier=Modifier? clauses+=Clauses)
	 */
	protected void sequence_MainClause(ISerializationContext context, MainClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns ModalitySentence
	 *     ModalitySentence returns ModalitySentence
	 *
	 * Constraint:
	 *     (
	 *         begin=SentenceBegin? 
	 *         actors=Actors 
	 *         modelity=Modality 
	 *         negation?=Negation? 
	 *         auxiliarVerb=AuxiliaryVerb? 
	 *         predicate=Predicate 
	 *         ending=SentenceEnding?
	 *     )
	 */
	protected void sequence_ModalitySentence(ISerializationContext context, ModalitySentence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     requirements+=Requirement+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ObjectConstraint returns ObjectConstraint
	 *
	 * Constraint:
	 *     object=Object
	 */
	protected void sequence_ObjectConstraint(ISerializationContext context, ObjectConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RequirementDSLPackage.Literals.OBJECT_CONSTRAINT__OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RequirementDSLPackage.Literals.OBJECT_CONSTRAINT__OBJECT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectConstraintAccess().getObjectObjectParserRuleCall_0(), semanticObject.getObject());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ObjectSet returns ObjectSet
	 *
	 * Constraint:
	 *     (elements+=Actor elements+=Actor*)
	 */
	protected void sequence_ObjectSet(ISerializationContext context, ObjectSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Object returns Object
	 *
	 * Constraint:
	 *     (article=PreNominative? (object+=WORD+ | object+=STRING))
	 */
	protected void sequence_Object(ISerializationContext context, de.fraunhofer.isst.stars.requirementDSL.Object semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PreNominative returns PreNominative
	 *
	 * Constraint:
	 *     (determiner=Quantification | article=Articles | article=RefArticles)
	 */
	protected void sequence_PreNominative(ISerializationContext context, PreNominative semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PredOrObject returns PredOrObject
	 *
	 * Constraint:
	 *     (predicate=Predicate | predObj=PredicateObject)
	 */
	protected void sequence_PredOrObject(ISerializationContext context, PredOrObject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PredicateObject returns PredicateObject
	 *
	 * Constraint:
	 *     (article=PreNominative (object+=WORD+ | object+=STRING))
	 */
	protected void sequence_PredicateObject(ISerializationContext context, PredicateObject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns PredicateSentence
	 *     PredicateSentence returns PredicateSentence
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             begin=SentenceBegin? 
	 *             actors=Actors 
	 *             auxNeg+=AuxNeg 
	 *             auxiliarVerb+=AuxiliaryVerb? 
	 *             preds=Preds? 
	 *             ending=SentenceEnding?
	 *         ) | 
	 *         (begin=SentenceBegin? actors=Actors preds=Preds ending=SentenceEnding?)
	 *     )
	 */
	protected void sequence_PredicateSentence(ISerializationContext context, PredicateSentence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Predicate returns Predicate
	 *
	 * Constraint:
	 *     (predicates+=WORD+ | predicates+=STRING | (predicates+=WORD+ object=PredicateObject))
	 */
	protected void sequence_Predicate(ISerializationContext context, Predicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Preds returns Preds
	 *
	 * Constraint:
	 *     (predicate=Predicate | predObj=PredicateObject)
	 */
	protected void sequence_Preds(ISerializationContext context, Preds semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns PropertySentence
	 *     PropertySentence returns PropertySentence
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             actors=Actors 
	 *             property=Property 
	 *             rela=Relation? 
	 *             modality=Modality 
	 *             negation?=Negation? 
	 *             auxiliarVerb=AuxiliaryVerb? 
	 *             predObj=PredOrObject 
	 *             ending=SentenceEnding?
	 *         ) | 
	 *         (
	 *             actors=Actors 
	 *             property=Property 
	 *             rela=Relation? 
	 *             auxNeg=AuxNeg 
	 *             (predObj=PredOrObject | constraints=Constraints) 
	 *             ending=SentenceEnding?
	 *         )
	 *     )
	 */
	protected void sequence_PropertySentence(ISerializationContext context, PropertySentence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Property returns Property
	 *
	 * Constraint:
	 *     (property+=WORD+ | property+=STRING)
	 */
	protected void sequence_Property(ISerializationContext context, Property semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelObjects returns RelObjects
	 *
	 * Constraint:
	 *     (object+=Object property+=Property? (relConj+=RelConjunction object+=Object property+=Property?)*)
	 */
	protected void sequence_RelObjects(ISerializationContext context, RelObjects semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Relation returns Relation
	 *
	 * Constraint:
	 *     (relposAdv=PositionAdverbial relDel=RelationDelimiter relComp=Comperators relElements=RelObjects)
	 */
	protected void sequence_Relation(ISerializationContext context, Relation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RequirementDSLPackage.Literals.RELATION__RELPOS_ADV) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RequirementDSLPackage.Literals.RELATION__RELPOS_ADV));
			if (transientValues.isValueTransient(semanticObject, RequirementDSLPackage.Literals.RELATION__REL_DEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RequirementDSLPackage.Literals.RELATION__REL_DEL));
			if (transientValues.isValueTransient(semanticObject, RequirementDSLPackage.Literals.RELATION__REL_COMP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RequirementDSLPackage.Literals.RELATION__REL_COMP));
			if (transientValues.isValueTransient(semanticObject, RequirementDSLPackage.Literals.RELATION__REL_ELEMENTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RequirementDSLPackage.Literals.RELATION__REL_ELEMENTS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationAccess().getRelposAdvPositionAdverbialParserRuleCall_0_0(), semanticObject.getRelposAdv());
		feeder.accept(grammarAccess.getRelationAccess().getRelDelRelationDelimiterParserRuleCall_1_0(), semanticObject.getRelDel());
		feeder.accept(grammarAccess.getRelationAccess().getRelCompComperatorsParserRuleCall_2_0(), semanticObject.getRelComp());
		feeder.accept(grammarAccess.getRelationAccess().getRelElementsRelObjectsParserRuleCall_3_0(), semanticObject.getRelElements());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RequirementText returns RequirementText
	 *
	 * Constraint:
	 *     (condClauses+=ConditionalClause? mainclauses=MainClause condClauses+=ConditionalClause?)
	 */
	protected void sequence_RequirementText(ISerializationContext context, RequirementText semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Requirement returns Requirement
	 *
	 * Constraint:
	 *     (reqID=ReqID? text=RequirementText)
	 */
	protected void sequence_Requirement(ISerializationContext context, Requirement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SentenceBegin returns SentenceBegin
	 *
	 * Constraint:
	 *     rela=Relation
	 */
	protected void sequence_SentenceBegin(ISerializationContext context, SentenceBegin semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RequirementDSLPackage.Literals.SENTENCE_BEGIN__RELA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RequirementDSLPackage.Literals.SENTENCE_BEGIN__RELA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSentenceBeginAccess().getRelaRelationParserRuleCall_0_0(), semanticObject.getRela());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SentenceEnding returns SentenceEnding
	 *
	 * Constraint:
	 *     (const+=Constraints+ | (const+=Constraints* rela=Relation) | (rela=Relation const+=Constraints+))
	 */
	protected void sequence_SentenceEnding(ISerializationContext context, SentenceEnding semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SetConstraint returns SetConstraint
	 *
	 * Constraint:
	 *     (set=ObjectSet | set=ValueSet)
	 */
	protected void sequence_SetConstraint(ISerializationContext context, SetConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitConstraints returns SingleValueConstraints
	 *     SingleValueConstraints returns SingleValueConstraints
	 *
	 * Constraint:
	 *     value=Value
	 */
	protected void sequence_SingleValueConstraints(ISerializationContext context, SingleValueConstraints semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RequirementDSLPackage.Literals.SINGLE_VALUE_CONSTRAINTS__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RequirementDSLPackage.Literals.SINGLE_VALUE_CONSTRAINTS__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSingleValueConstraintsAccess().getValueValueParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TimeConstraint returns TimeConstraint
	 *
	 * Constraint:
	 *     (ordinator=ConstraintOrdinators time=INT unit=TimeUnits)
	 */
	protected void sequence_TimeConstraint(ISerializationContext context, TimeConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RequirementDSLPackage.Literals.TIME_CONSTRAINT__ORDINATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RequirementDSLPackage.Literals.TIME_CONSTRAINT__ORDINATOR));
			if (transientValues.isValueTransient(semanticObject, RequirementDSLPackage.Literals.TIME_CONSTRAINT__TIME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RequirementDSLPackage.Literals.TIME_CONSTRAINT__TIME));
			if (transientValues.isValueTransient(semanticObject, RequirementDSLPackage.Literals.TIME_CONSTRAINT__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RequirementDSLPackage.Literals.TIME_CONSTRAINT__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeConstraintAccess().getOrdinatorConstraintOrdinatorsParserRuleCall_0_0(), semanticObject.getOrdinator());
		feeder.accept(grammarAccess.getTimeConstraintAccess().getTimeINTTerminalRuleCall_1_0(), semanticObject.getTime());
		feeder.accept(grammarAccess.getTimeConstraintAccess().getUnitTimeUnitsParserRuleCall_2_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ValueSet returns ValueSet
	 *
	 * Constraint:
	 *     (elements+=Value elements+=Value*)
	 */
	protected void sequence_ValueSet(ISerializationContext context, ValueSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     relativeClause returns relativeClause
	 *
	 * Constraint:
	 *     (sentence=relativeSentence (conjunction+=Conjunction condClauses+=ConditionalClause)*)
	 */
	protected void sequence_relativeClause(ISerializationContext context, relativeClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     relativeSentence returns relativeSentence
	 *
	 * Constraint:
	 *     (
	 *         (pronoun=RelativePronounsSubject modelity=Modality negation?=Negation? predicate=Predicate constraints+=Constraints*) | 
	 *         (pronoun=RelativePronounsSubject (auxiliar=WORD negation?=Negation)? predicate=Predicate constraints+=Constraints*) | 
	 *         (pronoun=RelativePronounsObject (clause=ModalitySentence | clause=PredicateSentence))
	 *     )
	 */
	protected void sequence_relativeSentence(ISerializationContext context, relativeSentence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
