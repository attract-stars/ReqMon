grammar de.fraunhofer.isst.stars.RequirementDSL with org.eclipse.xtext.common.Terminals hidden(WS, ML_COMMENT, SL_COMMENT, WS_HYPHEN)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate requirementDSL "http://www.fraunhofer.de/isst/automotive/stars/reqmon/dsl/requirement/RequirementDSL" 

/* =========== Model =========== */

Model:
	requirements+=Requirement*
;

//Requirement:
//	(condClauses+=Subclause)* (mainclauses+=Clauses) (condClauses+=Subclause)*
//	;

Requirement:
	//PROBLEM condClauses before and after mainClause lead to ambiguity
	'Req'? reqID=ReqID? ':' text=RequirementText ('.'|';') ('\n')+
;

RequirementText:
//	 ExistencePreface actors=Actors ','?   relativeClause=relativeClause  ','?  |
    (condClauses+=ConditionalClause ','? 'then' )?  (mainclauses=MainClause) (','? condClauses+=ConditionalClause)?
    //If mainclause is the second part then 'then' has to be added. IF maincluase is first part then 'then' is not necessary
;

/* =========== Clauses =========== */

ConditionalClause:
	ordinator=ClauseOrdinator clauses=Clauses
;

MainClause:
	modifier=Modifier? clauses+=Clauses //(conjunction+=Conjunction clauses+=MainClause)*
;


Clauses:
	clauses+= Clause (conjunction+=Conjunction clauses+=Clause)*	
;

Clause:
	ModalitySentence |  PredicateSentence | ExistenceSentence | PropertySentence
;


ModalitySentence :
	begin=SentenceBegin? actors=Actors modelity=Modality negation?=Negation? auxiliarVerb=AuxiliaryVerb? predicate=Predicate  ending=SentenceEnding?
	//actors=Actors modelity=Modality negation?=Negation? auxiliarVerb=AuxiliaryVerb? predicate=Predicate  constraints+=Constraints* 
;

PredicateSentence :
	begin=SentenceBegin? actors=Actors  auxNeg+=AuxNeg auxiliarVerb+=AuxiliaryVerb? preds=Preds?  ending=SentenceEnding? |
	begin=SentenceBegin? actors=Actors  preds=Preds  ending=SentenceEnding? 
	
	//actors=Actors  (auxiliarVerb+=WORD negation?=Negation)? predicate=Predicate  constraints+=Constraints* |
	//actors=Actors  predicate=Predicate constraints+=Constraints* |	
	//actors=Actors  auxiliarVerb+=AuxiliaryVerb negation?=Negation? auxiliarVerb+=AuxiliaryVerb? predicate=Predicate  constraints+=Constraints* |
	//actors=Actors  auxiliarVerb+=AuxiliaryVerb negation?=Negation? object=PredicateObject? constraints+=Constraints* 
;

ExistenceSentence :
	ExistencePreface actors=Actors ','   relativeClause=relativeClause  ',' 
;

PropertySentence:
	//TODO HIER SOLLTE MAN DOCH (ACTOR+PROPERTY)* haben!?
	actors=Actors property=Property rela=Relation? modality=Modality negation?=Negation? auxiliarVerb=AuxiliaryVerb? predObj=PredOrObject  ending=SentenceEnding? |
	actors=Actors property=Property rela=Relation? auxNeg=AuxNeg (predObj=PredOrObject | constraints=Constraints) ending=SentenceEnding?
	
	//property=Property modelity=Modality negation?=Negation? auxiliarVerb=AuxiliaryVerb? predicate=Predicate  constraints+=Constraints* |
	//property=Property modelity=Modality negation?=Negation? auxiliarVerb=AuxiliaryVerb object=PredicateObject?  constraints+=Constraints* |
	//property=Property auxiliarVerb=AuxiliaryVerb negation?=Negation? ((predicate=Predicate|object=PredicateObject) constraints+=Constraints* | constraints+=Constraints+)  |
	//property=Property (predicateWord=WORD| predicateWord=STRING) object=PredicateObject? constraints+=Constraints* //Leads to mismatch in xtext but not in AntLRworks
;

Property:
	PROPERTY_TERM (property+=WORD+ | property+=STRING)
;

SentenceBegin:
	(rela=Relation ',')
;

SentenceEnding:
	const+=Constraints+ |
	const+=Constraints* rela=Relation |
	rela=Relation const+=Constraints+
;

/* =========== RELATIVE CLAUSE =========== */


relativeClause:
//  pronoun=RelativePronouns actors=Actors? modelity=Modality? negation?=Negation? predicate=Predicate constraints+=Constraints*
	sentence=relativeSentence (conjunction+=Conjunction condClauses+=ConditionalClause)*	
;
relativeSentence :
	pronoun=RelativePronounsSubject modelity=Modality negation?=Negation? predicate=Predicate  constraints+=Constraints*  |
	pronoun=RelativePronounsSubject (auxiliar=WORD negation?=Negation)? predicate=Predicate  constraints+=Constraints* |
	pronoun=RelativePronounsObject  (clause=ModalitySentence | clause=PredicateSentence)
;

/* =========== CLAUSE ITEMS =========== */


Actors:
	actors+=Actor (conjunction+=Conjunction actors+=Actor)* 
;

Actor:
  	 PreNominative=PreNominative? (actor=WORD | actor=STRING) 
//    (determiner=Determiner|article=Articles|article=RefArticles)? (object=WORD | object=STRING) (property?=PROPERTY (adjectives+=Adjective)* (objects=WORD | objects=STRING))? 
   
;

Preds:
	predicate=Predicate | predObj=PredicateObject
;

Predicate:
	//verb=Verb | activity=Activity
	predicates+=WORD+ | predicates+=STRING | predicates+=WORD+ object=PredicateObject
;

PredicateObject:
	article=PreNominative (object+=WORD+ | object+=STRING) 
;

Object:
	article=PreNominative? (object+=WORD+ | object+=STRING) 
;

PredOrObject:
	predicate=Predicate | predObj=PredicateObject
;

ExistencePreface:
	{ExistencePreface} ('there' | 'There') (modifier=Modifier?) ('exist' | 'exists') // (WORD+|STRING) //defining the verbs for 'there is' / 'there are' is a problem for later usages of 'is'/'are' in other clauses
;

/* The same as Actors and Actor
Objects:
	(objects+=Object) (conjunction+=Conjunction objects+=Object)*
;

Object:
    PreNominative? (object+=WORD+ | object+=STRING)  
;
*/

AuxNeg:
	auxiliarVerb=AuxiliaryVerb negation=Negation? |
	auxiliarVerbNeg=AuxiliaryVerbNegation
;

PreNominative : 
	(determiner=Quantification|article=Articles|article=RefArticles)
;

Adverbial:
	SizeAdverbial | PositionAdverbial | ComparisonAdverbial	//| (WORD 'of')
;

/* =========== Relations =========== */

//Currently not used -> False identification of properties
Relation:
	relposAdv=PositionAdverbial relDel=RelationDelimiter relComp=Comperators relElements=RelObjects
;

RelObjects:
	object+=Object property+=Property? (relConj+=RelConjunction object+=Object property+=Property?)*
;


/*Properties:
	(properties+=Property) (conjunction+=Conjunction properties+=Property)* 
;*/


/* =========== CONSTRAINTS =========== */

Constraints:
	timeConstraint=TimeConstraint | constraint=Constraint
;

Constraint:
	ordinator=ConstraintOrdinators (constraint=ObjectConstraint | constraint=UnitConstraints | constraint= SetConstraint)
;	

ConstraintOrdinators:
	stuffing=StuffWord? adverbial=Adverbial comperator=Comperators?
;

SetConstraint:
	//Difference between ObjectSet and Value set in order to exclude a mixture of both in a single set
	set=ObjectSet  | set=ValueSet
;

TimeConstraint:
	ordinator=ConstraintOrdinators time=INT unit=TimeUnits
;

ObjectConstraint:
	  object=Object
;


UnitConstraints:
	 SingleValueConstraints | IntervallConstraints
;


IntervallConstraints:
	'[' lower=Value','higher=Value ']'
;

SingleValueConstraints:
	 value=Value
;

/* =========== VALUES =========== */


ValueSet:
	 '{' (elements+=Value) (';'elements+=Value)*'}'
;

ObjectSet:
	  '{' (elements+=Actor) (';'elements+=Actor)*'}'
;

Value:
	IntValue| FloatValue
;

IntValue:
	value=INT unit=Unit? object+=WORD*
;

FloatValue:
	value=FLOAT  unit=Unit? object+=WORD*
;

/* =========== BASIC TEXT BLOCKS / WORDS =========== */

ReqID returns  ecore::EString: 
	(ID|INT) ('.'|INT)* 
;

//just extension to allow naming with '-' like ego-lane -> ITS NOT MATCHED PROPERLY
WORD returns ecore::EString: 
	ID('-'ID)*
;

//overriding ID to include hyphen words 
@Override 
terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'-'|'0'..'9')*;

terminal WS_HYPHEN : ' - '; 

@Override
terminal WS : (' '|'\t'|'\r')+ ;

terminal PROPERTY_TERM returns ecore::EBoolean:
	//'\'s' |	'`s' |
	'´s'
;
/* =========== BASIC SYNTAX =========== */

RelationDelimiter:
	'relation'
	//'in' 'relation' 'to'  | 'relative' 'to' //mutiple word relation leads to false identification of properties
;

AuxiliaryVerb:
	'is' | 'are' | 'be' | 'been' | 'has' | 'have' | 'do' | 'does'
;

Conjunction:
	'and'| 'or'
;

RelConjunction:
	'and_to' | 'or_to'
;

Comperators:
	'than'|'as'|'to' | 'of'
;
		 
SizeAdverbial:
	'higher' | 'less'| 'more' | 'larger'|'smaller' | 'as_long_as'
;

PositionAdverbial:
	'between'|'next' | 'on' | 'above' | 'below' | 'in' | 'within' | 'in_front_of' | 'behind' | 'out' | 'under'
;

ComparisonAdverbial:
	'equal' | 'faster' | 'slower' | 'better' | 'by' | 'to'
;

Quantification:
	'all' | 'every' | 'each' | 'whole' | 'any' | 'several' | 'either' |
	'All' | 'Every' | 'Each' | 'Whole' | 'Any' | 'Several' | 'Either'
;

Negation:
	'not' //| 'donot' | 'doesnot' | 'doesn\'t' | 'don\'t'
;

AuxiliaryVerbNegation:
	'doesn´t' | 'don´t' | 'isn´t' | 'aren´t'
;

enum Modality:
	  SHALL = 'shall' | SHOULD = 'should' | WILL = 'will' | WOULD='would' | CAN='can' | COULD='could' | MUST='must'
;

enum Modifier:
	GLOBALLY='Globally' | GLOBALLY_L='globally' | ALWAYS='Always' | ALWAYS_L='always' | SOMETIMES='Sometimes' | SOMETIMES_L='sometimes' | EVENTUALLY='Eventually' | EVENTUALLY_L='eventually'
;

enum ClauseOrdinator:
	IF_L='if' | AFTER_L='after' | ONCE_L='once' | WHEN_L='when' | WHENEVER_L='whenever' | WHILE_L='while' | BEFORE_L='before' | UNTIL_L='until' |
	IF='If' | AFTER='After' | ONCE='Once' | WHEN='When' | WHENEVER='Whenever' | WHILE='While' | BEFORE='Before' | UNTIL='Until'
;

Articles:
	'the' | 'a' | 'an' | 
	'The' | 'A' | 'An' 
;

RefArticles:
	'that' | 'this' | 'That' | 'This'
;

StuffWord:
	'with'
;
	
// Separation of Relative Pronouns due to impact on the following sentence structure
RelativePronounsSubject:
	'which' | 'who' | 'that'
;

RelativePronounsObject:
	'whose'| 'whom'
;

/* =========== BASIC UNITS =========== */

FLOAT returns ecore::EFloat:
	INT'.'INT
;

Unit:
	 LengthUnits | PresureUnits | HeatUnits | MassUnits | VelcoityUnits | Cuvature
;


Cuvature:
	'rad/m' | '°' | 'rad' | '°/m'	
;

VelcoityUnits:
	'm/s' | 'knots'  |'km/h' | 'm/min'
	;

MassUnits:
	'kg'| 'g' | 'mg' | 't'
;

HeatUnits:
	'C' | 'F'
;

PresureUnits:
	'bar' | 'Pa' | 'hPa'
;


LengthUnits:
	'm' | 'f' | 'km' | 'cm' | 'mm' |'nm'
;

TimeUnits:
	 'ns'|'ms'|'s' | 'sec' | 'second' | 'seconds'| 'minute' | 'minutes' | 'min' | 'hour' | 'hours' | 'h' | 'day' | 'days' | 'd' | 'month'| 'months' | 'mon' |'year'| 'years'| 'y' 
;
