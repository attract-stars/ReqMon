grammar de.fraunhofer.isst.stars.RequirementDSL with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate requirementDSL "http://www.fraunhofer.de/isst/automotive/stars/reqmon/dsl/requirement/RequirementDSL"

/* =========== Model =========== */

Model:
	requirements+=Requirement*
;

//Requirement:
//	(condClauses+=Subclause)* (mainclauses+=Clauses) (condClauses+=Subclause)*
//	;

Requirement:
	//PROBLEM condClauses before and after mainClause lead to ambiguity
	'Req'? reqID=ReqID? (':'|'.') text=RequirementText ('.'|';')
;

RequirementText:
//	 ExistencePreface actors=Actors ','?   relativeClause=relativeClause  ','?  |
    (condClauses+=ConditionalClause ','? 'then' )?  (mainclauses=MainClause) (','? condClauses+=ConditionalClause)?
    //If mainclause is the second part then 'then' has to be added. IF maincluase is first part then 'then' is not necessary
;

/* =========== Clauses =========== */

ConditionalClause:
	ordinator=ClauseOrdinator clauses=Clauses
;

MainClause:
	modifier=Modifier? clauses+=Clause //(conjunction+=Conjunction clauses+=MainClause)*
;


Clauses:
	clauses+= Clause (conjunction+=Conjunction clauses+=Clause)*	
;

Clause:
	ModalitySentence |  PredicateSentence | ExistenceSentence | PropertySentence
;


ModalitySentence :
	actors=Actors modelity=Modality negation?=Negation? predicate=Predicate  constraints+=Constraints* 
;

PredicateSentence :
	actors=Actors  (auxiliar=WORD negation?=Negation)? predicate=Predicate  constraints+=Constraints*
;

ExistenceSentence :
	ExistencePreface actors=Actors ','   relativeClause=relativeClause  ',' 
;

PropertySentence:
	property=Property  modelity=Modality? negation?=Negation? (predicate=WORD|predicate=STRING)  constraints+=Constraints+
	//TODO WAS IST MIT IS STARTED
;

Property:
	(determiner=Determiner|article=Articles|article=RefArticles)? (object=WORD | object=STRING) PROPERTY_TERM (adjectives+=Adjective)* (objects=WORD | objects=STRING) 
;

/* =========== RELATIVE CLAUSE =========== */


relativeClause:
//  pronoun=RelativePronouns actors=Actors? modelity=Modality? negation?=Negation? predicate=Predicate constraints+=Constraints*
	sentence= relativeSentence (conjunction+=Conjunction condClauses+=ConditionalClause)*	
;
relativeSentence :
	pronoun=RelativePronounsSubject modelity=Modality negation?=Negation? predicate=Predicate  constraints+=Constraints*  |
	pronoun=RelativePronounsSubject (auxiliar=WORD negation?=Negation)? predicate=Predicate  constraints+=Constraints* |
	pronoun=RelativePronounsObject  (clause=ModalitySentence | clause=PredicateSentence)
;

/* =========== CLAUSE ITEMS =========== */


Actors:
	(actors+=Actor) (conjunction+=Conjunction actors+=Actor)* 
;

Actor:
  	 PreNominative? (object=WORD | object=STRING) 
//    (determiner=Determiner|article=Articles|article=RefArticles)? (object=WORD | object=STRING) (property?=PROPERTY (adjectives+=Adjective)* (objects=WORD | objects=STRING))? 
   
;

Predicate:
	//verb=Verb | activity=Activity
	predicates+=WORD+ | predicates+=STRING | predicates+=WORD+ article=PreNominative predicates+=WORD+
;

ExistencePreface:
	{ExistencePreface} 'there' (modifier=Modifier?) (WORD+|STRING) //defining the verbs for 'there is' / 'there are' is a problem for later usages of 'is'/'are' in other clauses
;

Objects:
	(actors+=Object) (conjunction+=Conjunction actors+=Object)*
;

Object:
    PreNominative? (adjectives+=Adjective)* (objects=WORD | objects=STRING)  
;

PreNominative : 
	(determiner=Determiner|article=Articles|article=RefArticles)
;

Adjective:
	adjective=WORD | adjective=STRING
;

Adverbial:
	SizeAdverbial | PositionAdverbial | ComparisonAdverbial	| (WORD 'of')
;

/* =========== VALUES =========== */


ValueSet:
	 '{' (elements+=Value) (';'elements+=Value)*'}'
;

ObjectSet:
	  '{' (elements+=Object) (';'elements+=Object)*'}'
;

Value:
	IntValue| FloatValue
;

IntValue:
	value=INT unit=Unit?
;

FloatValue:
	value=FLOAT  unit=Unit?
;



/* =========== CONSTRAINTS =========== */

Constraints:
	timeConstraint= TimeConstraint | constraint=Constraint
;

Constraint:
	ordinator=ConstraintOrdinators (constraint=ObjectConstraint | constraint=UnitConstraints | constraint= SetConstraint)
;	

ConstraintOrdinators:
	stuffing=StuffWord? adverbial=Adverbial comperator=Comperators?
;


	
SetConstraint:
	//Difference between ObjectSet and Value set in order to exclude a mixture of both in a single set
	set=ObjectSet  | set=ValueSet
;

TimeConstraint:
	ordinator=ConstraintOrdinators time=INT unit=TimeUnits
;

ObjectConstraint:
	  object=Object
;


UnitConstraints:
	 SingleValueConstraints | IntervallConstraints
;


IntervallConstraints:
	'[' lower=Value','higher=Value ']'
;

SingleValueConstraints:
	 value=Value
;

/* =========== XXX =========== */

ReqID returns  ecore::EString: 
	(ID|INT) ('.'|INT)*
;

//just extension to allow naming with '-' like ego-lane
WORD returns ecore::EString: 
	ID('-'ID)*
;

terminal PROPERTY_TERM returns ecore::EBoolean:
	'\'s' |	'`s' | '´s'
;
/* =========== BASIC SYNTAX =========== */

Conjunction:
	'and'| 'or';

Comperators:
	'than'|'as'|'to' | 'of'
;
		 
SizeAdverbial:
	'higher' | 'less'| 'more' | 'larger'|'smaller' | 'as_long_as'
;

PositionAdverbial:
	'between'|'next' | 'on' | 'above' | 'below' | 'in' | 'within' | 'in_front_of' | 'behind' | 'out' 
;

ComparisonAdverbial:
	'equal' | 'faster' | 'slower' | 'better' | 'to' | 'by'
;

Determiner:
	'all' | 'every' | 'each' | 'whole' | 'any' | 'several' | 'either'
	'All' | 'Every' | 'Each' | 'Whole' | 'Any' | 'Several' | 'Either'
;

Negation:
	'not' | 'donot' | 'doesnot' | 'doesn\'t' | 'don\'t'
;

enum Modality:
	  SHALL = 'shall' | SHOULD = 'should' | WILL = 'will' | WOULD='would' | CAN='can' | COULD='could' | MUST='must'
;

enum Modifier:
	GLOBALLY='Globally' | GLOBALLY='globally' | ALWAYS='Always' | ALWAYS='always' | SOMETIMES='Sometimes' | SOMETIMES='sometimes' | EVENTUALLY='Eventually' | EVENTUALLY='eventually'
;

enum ClauseOrdinator:
	IF='if' | AFTER='after' | ONCE='once' | WHEN='when' | WHENEVER='whenever' | WHILE='while' | BEFORE='before' | UNTIL='until' |
	IF='If' | AFTER='After' | ONCE='Once' | WHEN='When' | WHENEVER='Whenever' | WHILE='While' | BEFORE='Before' | UNTIL='Until'
;

Articles:
	'the' | 'a' | 'an' | 
	'The' | 'A' | 'An' 
;

RefArticles:
	'that' | 'this' | 'That' | 'This'
;

StuffWord:
	'with'
;
	
// Separation of Relative Pronouns due to impact on the following sentence structure
RelativePronounsSubject:
	'which' | 'who' | 'that'
;

RelativePronounsObject:
	'whose'| 'whom'
;

/* =========== BASIC UNITS =========== */

terminal FLOAT returns ecore::EFloat:
	INT'.'INT
;

Unit:
	 LengthUnits | PresureUnits | HeatUnits | MassUnits | VelcoityUnits | Cuvature
;


Cuvature:
	'rad/m' | '°' | 'rad' | '°/m'	
;

VelcoityUnits:
	'm/s' | 'knots'  |'km/h' | 'm/min'
	;

MassUnits:
	'kg'| 'g' | 'mg' | 't'
;

HeatUnits:
	'C' | 'F'
;

PresureUnits:
	'bar' | 'Pa' | 'hPa'
;


LengthUnits:
	'm' | 'f' | 'km' | 'cm' | 'mm' |'nm'
;

TimeUnits:
	 'ns'|'ms'|'s' | 'sec' | 'second' | 'seconds'| 'minute' | 'minutes' | 'min' | 'hour' | 'hours' | 'h' | 'day' | 'days' | 'd' | 'month'| 'months' | 'mon' |'year'| 'years'| 'y' 
;
