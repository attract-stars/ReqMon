grammar de.fraunhofer.isst.stars.RequirementDSL with org.eclipse.xtext.common.Terminals hidden(WS, ML_COMMENT, SL_COMMENT, WS_HYPHEN)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate requirementDSL "http://www.fraunhofer.de/isst/automotive/stars/reqmon/dsl/requirement/RequirementDSL" 

/* =========== Model =========== */
//TODO WIR BRAUCHEN EIN BESSERES OBJECT IN DER SPRACHE FÜR OBJECT + PROPERTY denn eig ist das eine Einheit
//TODO RENAME MODEL
Model:
	requirements+=Requirement*
;

//Requirement:
//	(condClauses+=Subclause)* (mainclauses+=Clauses) (condClauses+=Subclause)*
//	;

Requirement:
	//PROBLEM condClauses before and after mainClause lead to ambiguity
	'Req' reqID=ReqID? ':' text=RequirementText ('.'|';')
;

RequirementText:
//	 ExistencePreface actors=Actors ','?   relativeClause=relativeClause  ','?  |
    (condClauses+=ConditionalClause ','? 'then' )?  (mainclauses=MainClause) (','? condClauses+=ConditionalClause)?
    //If mainclause is the second part then 'then' has to be added. IF maincluase is first part then 'then' is not necessary
;

/* =========== Clauses =========== */

ConditionalClause:
	ordinator=ClauseOrdinator clauses=Clauses
;

MainClause:
	modifier=Modifier? clauses+=Clauses //(conjunction+=Conjunction clauses+=MainClause)*
;


Clauses:
	clauses+= Clause (conjunction+=Conjunction clauses+=Clause)*	
;

Clause:
	ModalitySentence |  PredicateSentence | ExistenceSentence | PropertySentence
;


ModalitySentence :
	begin=SentenceBegin? actors=Actors modelity=Modality negation?=Negation? auxiliarVerb=AuxiliaryVerb? predicate=Predicate  ending=SentenceEnding?
	//actors=Actors modelity=Modality negation?=Negation? auxiliarVerb=AuxiliaryVerb? predicate=Predicate  constraints+=Constraints* 
;

PredicateSentence :
	begin=SentenceBegin? actors=Actors  auxNeg=AuxNeg auxiliarVerb=AuxiliaryVerb? preds=Preds?  ending=SentenceEnding? |
	begin=SentenceBegin? actors=Actors  preds=Preds  ending=SentenceEnding? 
	
	//actors=Actors  (auxiliarVerb+=WORD negation?=Negation)? predicate=Predicate  constraints+=Constraints* |
	//actors=Actors  predicate=Predicate constraints+=Constraints* |	
	//actors=Actors  auxiliarVerb+=AuxiliaryVerb negation?=Negation? auxiliarVerb+=AuxiliaryVerb? predicate=Predicate  constraints+=Constraints* |
	//actors=Actors  auxiliarVerb+=AuxiliaryVerb negation?=Negation? object=PredicateObject? constraints+=Constraints* 
;

ExistenceSentence :
	Existence actors=Actors ','   relativeClause=RelativeClause  ',' 
;

PropertySentence:
	//TODO HIER SOLLTE MAN DOCH (ACTOR+PROPERTY)* haben!?
	//TODO mach hier auch Preds sinn?+
	//TODO Warum haben wir hier constraints im ODER und nohcmal im SentenceEnding - Reicht hier nicht auch PredOrObject?
	actors=Actors property=Property rela=Relation? modality=Modality negation?=Negation? auxiliarVerb=AuxiliaryVerb? predObj=PredOrObject  ending=SentenceEnding? |
	actors=Actors property=Property rela=Relation? auxNeg=AuxNeg (predObj=PredOrObject | constraints=Constraints) ending=SentenceEnding?
	
	//property=Property modelity=Modality negation?=Negation? auxiliarVerb=AuxiliaryVerb? predicate=Predicate  constraints+=Constraints* |
	//property=Property modelity=Modality negation?=Negation? auxiliarVerb=AuxiliaryVerb object=PredicateObject?  constraints+=Constraints* |
	//property=Property auxiliarVerb=AuxiliaryVerb negation?=Negation? ((predicate=Predicate|object=PredicateObject) constraints+=Constraints* | constraints+=Constraints+)  |
	//property=Property (predicateWord=WORD| predicateWord=STRING) object=PredicateObject? constraints+=Constraints* //Leads to mismatch in xtext but not in AntLRworks
;

Property:
	PROPERTY_TERM relativ='relative'? (property+=WORD+ | property+=STRING)
;

SentenceBegin:
	(rela=Relation ',')
;

SentenceEnding:
	//TODO FEHLT HIER NICHT EINE Conjunction?!
	//TODO SOLLTE nicht Relation in CONTRAINTS drin sein
	const+=Constraints+ |
	const+=Constraints* rela=Relation |
	rela=Relation const+=Constraints+
;

/* =========== RELATIVE CLAUSE =========== */


RelativeClause:
	//TODO WARUM WIRD HIER DER CONTITIONAL CLAUSE RAUFGERUFEN UND NICHT IN EXISTING CLAUSE
//  pronoun=RelativePronouns actors=Actors? modelity=Modality? negation?=Negation? predicate=Predicate constraints+=Constraints*
	sentence=RelativeSentence (conjunction+=Conjunction condClauses+=ConditionalClause)*	
;
RelativeSentence :
	//TODO Here the auxiliar is any word and not one predefine by AUXILIARVERB
	pronoun=RelativePronounsSubject modelity=Modality negation?=Negation? predicate=Predicate  constraints+=Constraints*  |
	pronoun=RelativePronounsSubject (auxiliar=WORD negation?=Negation)? predicate=Predicate  constraints+=Constraints* |
	pronoun=RelativePronounsObject  (clause=ModalitySentence | clause=PredicateSentence)
;

/* =========== CLAUSE ITEMS =========== */


Actors:
	actors+=Actor (conjunction+=Conjunction actors+=Actor)* 
;

Actor:
  	  PreNominative=PreNominative? relativ='relative'? (actor=WORD | actor=STRING) 
//    (determiner=Determiner|article=Articles|article=RefArticles)? (object=WORD | object=STRING) (property?=PROPERTY (adjectives+=Adjective)* (objects=WORD | objects=STRING))? 
   
;

Preds:
	//TODO WARUM KANN DAS NICHT HIER EINFACH PREDICATE SEIN und erhalt PREDOBJ als eigenes Element?
	predicate=Predicate | predObj=PredicateObject
;

Predicate:
	//verb=Verb | activity=Activity
	predicates+=WORD+ | predicates+=STRING | predicates+=WORD+ object=PredicateObject
;

PredicateObject:
	article=PreNominative relativ='relative'? (object+=WORD+ | object+=STRING) 
;

Object:
	article=PreNominative? relativ='relative'? (object+=WORD+ | object+=STRING) 
;

PredOrObject:
	predicate=Predicate | predObj=PredicateObject
;

Existence:
	{ExistencePreface} ('there' | 'There') (modifier=Modifier?) ('exist' | 'exists') // (WORD+|STRING) //defining the verbs for 'there is' / 'there are' is a problem for later usages of 'is'/'are' in other clauses
;

/* The same as Actors and Actor
Objects:
	(objects+=Object) (conjunction+=Conjunction objects+=Object)*
;

Object:
    PreNominative? (object+=WORD+ | object+=STRING)  
;
*/

AuxNeg:
	auxiliarVerb=AuxiliaryVerb negation=Negation? |
	auxiliarVerbNeg=AuxiliaryVerbNegation
;

PreNominative : 
	(determiner=Quantification|article=Articles|article=RefArticles)
;

Adverbial:
	SizeAdverbial | PositionAdverbial | ComparisonAdverbial //| PositionAdverbial PositionAdverbial Comperators	
	//| (WORD 'of')
;

/* =========== Relations =========== */

Relation:
	/*relposAdv=PositionAdverbial*/ relDel=RelationDelimiter /*relComp=Comperators*/ relElements=RelObjects
;

RelObjects:
	object+=Object property+=Property? (relConj+=RelConjunction object+=Object property+=Property?)*
;


/*Properties:
	(properties+=Property) (conjunction+=Conjunction properties+=Property)* 
;*/


/* =========== CONSTRAINTS =========== */

Constraints:
	timeConstraint=TimeConstraint | constraint=Constraint
;

Constraint:
	ordinator=ConstraintOrdinators (constraint=ObjectConstraint | constraint=UnitConstraints | constraint= SetConstraint)
;	

ConstraintOrdinators:
	stuffing=StuffWord? adverbial=Adverbial comperator=Comperators?
;

SetConstraint:
	//Difference between ObjectSet and Value set in order to exclude a mixture of both in a single set
	set=ObjectSet  | set=ValueSet
;

TimeConstraint:
	ordinator=ConstraintOrdinators time=INT unit=TimeUnits
;

ObjectConstraint:
	  object=Object
;


UnitConstraints:
	 SingleValueConstraints | IntervallConstraints
;


IntervallConstraints:
	'[' lower=Value','higher=Value ']'
;

SingleValueConstraints:
	 value=Value
;

/* =========== VALUES =========== */


ValueSet:
	 '{' (elements+=Value) (';'elements+=Value)*'}'
;

ObjectSet:
	  '{' (elements+=Actor) (';'elements+=Actor)*'}'
;

Value:
	IntValue| FloatValue
;

IntValue:
	value=INT unit=Unit? object+=WORD*
;

FloatValue:
	value=FLOAT  unit=Unit? object+=WORD*
;

/* =========== BASIC TEXT BLOCKS / WORDS =========== */

ReqID returns  ecore::EString: 
	(ID|INT) ('.'|INT)* 
;

//just extension to allow naming with '-' like ego-lane -> ITS NOT MATCHED PROPERLY
WORD returns ecore::EString: 
	ID('-'ID)*
;

//overriding ID to include hyphen words 
@Override 
terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'-'|'0'..'9')*;

// overriding STRING to allow only the '"' quote (the "'" quote is needed for the Property-term)
@Override
terminal STRING: 
	'"' ( '\\'('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|'"') )* '"'
;

terminal WS_HYPHEN : ' - '; 

//@Override
//terminal WS : (' '|'\t'|'\r')+ ;

terminal PROPERTY_TERM returns ecore::EBoolean:
	'\'s' |	'`s' | '´s'
;
/* =========== BASIC SYNTAX =========== */

RelationDelimiter:
	//'relation'
	'in' 'relation' 'to'  | 'relative' 'to' |
	'In' 'relation' 'to'  | 'Relative' 'to' 
;

AuxiliaryVerb:
	'is' | 'are' | 'be' | 'been' | 'has' | 'have' | 'do' | 'does'
;

Conjunction:
	'and'| 'or'
;

RelConjunction:
	'and' 'to' | 'or' 'to'
;

Comperators:
	'than'|'as'|'to' | 'of'
;
		 
SizeAdverbial:
	'higher' | 'less'| 'more' | 'larger'|'smaller' | 'as' 'long' 'as'
;

PositionAdverbial:
	'between'|'next' | 'on' | 'above' | 'below' | 'in' | 'within' | 'in' 'front' 'of' | 'in' 'front' 'to' 
	| 'behind' | 'out' | 'under'
;

ComparisonAdverbial:
	'equal' | 'faster' | 'slower' | 'better' | 'by' | 'to'
;

Quantification:
	'all' | 'every' | 'each' | 'whole' | 'any' | 'several' | 'either' |
	'All' | 'Every' | 'Each' | 'Whole' | 'Any' | 'Several' | 'Either'
;

Negation:
	'not' //| 'donot' | 'doesnot' | 'doesn\'t' | 'don\'t'
;

AuxiliaryVerbNegation:
	//TODO MUSS HIER NICHT AUCH ANDERE ABOSTROPH HINZU
	'doesn\'t' | 'don\'t' | 'isn\'t' | 'aren\'t'
;

enum Modality:
	  SHALL = 'shall' | SHOULD = 'should' | WILL = 'will' | WOULD='would' | CAN='can' | COULD='could' | MUST='must'
;

enum Modifier:
	GLOBALLY='Globally' | GLOBALLY_L='globally' | ALWAYS='Always' | ALWAYS_L='always' | SOMETIMES='Sometimes' | SOMETIMES_L='sometimes' | EVENTUALLY='Eventually' | EVENTUALLY_L='eventually'
;

enum ClauseOrdinator:
	IF_L='if' | AFTER_L='after' | ONCE_L='once' | WHEN_L='when' | WHENEVER_L='whenever' | WHILE_L='while' | BEFORE_L='before' | UNTIL_L='until' |
	IF='If' | AFTER='After' | ONCE='Once' | WHEN='When' | WHENEVER='Whenever' | WHILE='While' | BEFORE='Before' | UNTIL='Until'
;

Articles:
	'the' | 'a' | 'an' | 
	'The' | 'A' | 'An' 
;

RefArticles:
	'that' | 'this' | 'That' | 'This'
;

StuffWord:
	'with'
;
	
// Separation of Relative Pronouns due to impact on the following sentence structure
RelativePronounsSubject:
	'which' | 'who' | 'that'
;

RelativePronounsObject:
	'whose'| 'whom'
;

/* =========== BASIC UNITS =========== */

FLOAT returns ecore::EFloat:
	INT'.'INT
;

Unit:
	 LengthUnits | PresureUnits | HeatUnits | MassUnits | VelcoityUnits | Cuvature
;


Cuvature:
	'rad/m' | '°' | 'rad' | '°/m'	
;

VelcoityUnits:
	'm/s' | 'knots'  |'km/h' | 'm/min'
	;

MassUnits:
	'kg'| 'g' | 'mg' | 't'
;

HeatUnits:
	'C' | 'F'
;

PresureUnits:
	'bar' | 'Pa' | 'hPa'
;


LengthUnits:
	'm' | 'f' | 'km' | 'cm' | 'mm' |'nm'
;

TimeUnits:
	 'ns'|'ms'|'s' | 'sec' | 'second' | 'seconds'| 'minute' | 'minutes' | 'min' | 'hour' | 'hours' | 'h' | 'day' | 'days' | 'd' | 'month'| 'months' | 'mon' |'year'| 'years'| 'y' 
;
